### [父子域如何用cookies实现在父域登录而子域不用登录](https://blog.csdn.net/weixin_39996101/article/details/111789110)

### [http请求怎么加快速度]()

```js
使用CDN
浏览器缓存
使用HTTP2
----------------
减少http请求
把图片合成雪碧图 
使用webpack合并css和js，减少文件数量，
```

### [首屏优化](https://juejin.cn/post/6949896020788690958)

### [如果有很多图片导致页面卡顿怎么解决]()

```js
懒加载 骨架屏
把图片合成雪碧图
图片转成base64
缓存
压缩图片
webp
```

### [z-index](https://juejin.cn/post/6844903667175260174)

```js
在html笔记
```

### [js中动画渲染如何保证流畅度](https://www.jianshu.com/p/fc0b79018a84)

### [为什么会有微任务](https://blog.csdn.net/qq_41732961/article/details/117675693)

```js
微任务执行更快。当有紧急任务就可以放倒微任务队列之中，就可以在本次事件循环处理微任务队列的任务。而不用等到下个宏任务。总的来说就是为了插队

##微任务和宏任务区别
执行顺序不同


```

### [webpack打包流程](https://juejin.cn/post/6943468761575849992)

```js
1、读取webpack的配置参数；
2、启动webpack，创建Compiler对象并开始解析项目；
3、从入口文件（entry）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；
4、对不同文件类型的依赖模块文件使用对应的Loader进行编译，最终转为Javascript文件；
5、webpack通过订阅发布模式，在特定的时间广播出一些事件，插件监听到了感兴趣的事件就会执行任务，实现插件的功能

模块打包。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。
编译兼容。对代码做polyfill，还可以编译转换浏览器识别不了的文件
功能扩展。通过webpack的Plugin机制，可以进一步实现诸如按需加载，代码压缩等一系列功能
```





### [nextTick]()

```js

当我们去修改数据之后进行dom操作，是获取不到更新后dom数据，vue更新dom数据是异步的  首先修改数据不会立马更新dom，而是把所有的变更数据放到一个队列之中。如果一个数据被修改多次，那会经过去重只会放进队列一次。等到所有的数据修改完就会全部执行
为了能够基于dom更新后操作dom。我们就可以使用nexttick函数。它的回调函数会等到dom更新完成之后去执行
首先会把回调函数放到一个callbacks的数组之中。然后会执行一个timerfun的函数，会根据浏览器环境，选择把执行callbacks数组的函数放到微任务还是宏任务，优先是使用promise.then，最后才会使用settimeout，而这个执行函数主要把数组的回调函数取出来并且执行，然后清空
```

```js
权限管理，它的流程是 首先进入到路由，先判断有没有token 如果没有，再判断是否为白名单里的路由，是的话就直接跳转，不是的话就重定向到登录页面。有token后，判断进去的路由是否为login，是的话就跳转到首页。不是login。再去判断是否有角色。有角色就直接跳转。没有就去获取用户信息拿到对应的角色。再根据角色，从asyncRouter筛选出这个角色权限的路由。并且使用addRouters方法放到router中。菜单也是根据router去动态生成的。最后用户退出登录的时候，把router进行重置。对于有些按钮可以进行权限控制显示，使用指令的方式或者v-if的方式都可以实现。
一开始值考虑了完成项目的功能，却没有考虑对项目进行优化，因此我又对项目进行了优化
首先是对体积进行优化
移除项目模板冗余依赖，将public的静态资源移入assets。这样就不会被webpack打包到dist文件
对图片进行压缩，对图片格式转化成webp
对UI组件框架进行按需加载，
对core.js进行按需引入
传输优化
路由懒加载
vue-cli默认会把所有的npm依赖打包进一个chunk，会导致chunk体积很大，所以要进行代码分割
使用prefetch和preload 预先获取资源以及缓存资源 优化用户体验
gzip压缩传输
使用浏览器缓存
感知优化。
在获取页面内容之前可以用骨架屏，以及等待的时候可以使用loading动画 来优化用户体验
```

### [权限管理]()

```js
首先进入到路由，先判断有没有token 如果没有，再判断是否为白名单里的路由，是的话就直接跳转，不是的话就重定向到登录页面。有token后，判断进去的路由是否为login，是的话就跳转到首页。不是login。再去判断是否有角色。有角色就直接跳转。没有就去获取角色。再根据角色，从asyncRouter筛选出这个角色权限的路由。并且使用addRouters方法放到router中。菜单也是根据router去生成的。
最后用户退出去的时候，把router进行重置一下。这就是权限管理的大概流程。有需求的话也可以对按钮进行权限控制，有权限就v-if进行展示
```

### [Webpack 和 Vite，Vite 为什么快？]()
Webpack 和 Vite 都是现代前端开发中常用的构建工具，但它们在设计和实现上有很大的不同，尤其是在启动和热更新（HMR）的速度上。Vite 之所以快，主要有以下几个原因：

### 1. **基于原生 ES 模块（ESM）**
   - **Webpack**：Webpack 是一个打包工具，它将所有的模块打包成一个或多个 bundle。在开发环境中，Webpack 需要将所有模块打包成一个 bundle 后才能启动开发服务器，这个过程通常需要较长的时间。
   - **Vite**：Vite 利用了现代浏览器对 ES 模块的原生支持。在开发环境中，Vite 直接将源代码作为 ES 模块提供给浏览器，而不需要打包。这意味着在启动开发服务器时，Vite 不需要进行复杂的打包过程，因此启动速度非常快。

### 2. **按需编译**
   - **Webpack**：Webpack 在启动时需要对整个项目进行编译，包括所有的依赖和代码。这个过程可能会非常耗时，尤其是在大型项目中。
   - **Vite**：Vite 采用按需编译的策略。只有在浏览器请求某个模块时，Vite 才会对其进行编译。这种方式大大减少了启动时间和热更新的延迟。

### 3. **热更新（HMR）**
   - **Webpack**：Webpack 的热更新机制依赖于打包后的 bundle。当文件发生变化时，Webpack 需要重新打包并更新 bundle，这个过程可能会导致热更新的延迟。
   - **Vite**：Vite 的热更新机制基于 ES 模块的特性。当文件发生变化时，Vite 只需要重新编译和提供发生变化的模块，而不需要重新打包整个应用。这种方式使得热更新的速度非常快。

### 4. **预构建依赖**
   - **Vite**：Vite 在启动时会预构建项目中的依赖（如 npm 包），并将其转换为 ES 模块格式。这个过程只需要在第一次启动时进行，后续启动时可以直接使用预构建的结果，从而进一步加快启动速度。

### 5. **轻量级开发服务器**
   - **Webpack**：Webpack 的开发服务器（webpack-dev-server）功能强大，但也相对复杂，启动时需要加载和配置许多插件和中间件。
   - **Vite**：Vite 的开发服务器设计得非常轻量级，专注于提供快速的开发体验。它不需要复杂的配置，启动速度更快。

### 6. **现代浏览器支持**
   - **Vite**：Vite 假设开发环境使用的是现代浏览器，这些浏览器对 ES 模块有良好的支持。因此，Vite 可以充分利用现代浏览器的特性，而不需要像 Webpack 那样考虑对旧版浏览器的兼容性。

### 总结
Vite 之所以快，主要是因为它利用了现代浏览器对 ES 模块的原生支持，采用了按需编译和轻量级的开发服务器设计，以及高效的预构建和热更新机制。这些特性使得 Vite 在开发环境中的启动速度和热更新速度都远超传统的打包工具如 Webpack。



### [http2虽然有多路服用但是Queued at 2.74 s的时间更长了啊，为什么]()
HTTP/2 虽然支持多路复用（multiplexing），允许多个请求和响应在同一个 TCP 连接上并行传输，但这并不意味着所有请求都会立即开始处理。实际上，HTTP/2 的请求队列管理比 HTTP/1.1 更加复杂，因为它需要考虑更多的因素，如请求优先级、流控制、资源类型等。

### HTTP/2 中的 `Queued` 时间
在 HTTP/2 中，`Queued` 时间可能比 HTTP/1.1 更长的原因包括：

1. **请求优先级**：HTTP/2 允许为每个请求设置优先级。浏览器会根据请求的优先级来决定请求的处理顺序。低优先级的请求可能会被延迟处理，从而导致 `Queued` 时间更长。
2. **流控制**：HTTP/2 引入了流控制机制，用于管理每个流的带宽分配。如果某个流的带宽被限制，相关的请求可能会被延迟处理，从而导致 `Queued` 时间更长。
3. **资源类型**：不同类型的资源（如 HTML、CSS、JavaScript、图片）可能有不同的处理优先级。低优先级的资源（如图片）可能会被延迟处理，从而导致 `Queued` 时间更长。
4. **并发限制**：虽然 HTTP/2 支持多路复用，但浏览器仍然会对每个域名的并发请求数量进行限制。如果当前有太多请求正在进行，新的请求可能会被阻塞，直到有其他请求完成。

### 示例
假设在某个时间点，浏览器需要发送多个请求：

1. **请求 A**：优先级高，资源类型为 HTML，`Queued` 时间可能是 `0.000s`。
2. **请求 B**：优先级低，资源类型为图片，`Queued` 时间可能是 `2.74s`。

### 总结
- **请求优先级**：HTTP/2 允许为每个请求设置优先级，低优先级的请求可能会被延迟处理。
- **流控制**：HTTP/2 引入了流控制机制，用于管理每个流的带宽分配，可能会导致请求被延迟处理。
- **资源类型**：不同类型的资源可能有不同的处理优先级，低优先级的资源可能会被延迟处理。
- **并发限制**：浏览器仍然会对每个域名的并发请求数量进行限制，可能会导致请求被阻塞。

理解这些因素有助于分析和优化网页加载性能，特别是在使用 HTTP/2 时。通过合理设置请求优先级、优化资源类型和流控制策略，可以减少 `Queued` 时间，提高网页的加载速度和用户体验。


Vite 之所以比 Webpack 启动快，主要是因为它在设计上采用了不同的策略，充分利用了现代浏览器对 ES 模块（ESM）的原生支持。以下是 Vite 比 Webpack 启动快的主要原因：

### 1. **原生 ES 模块支持**
   - **Webpack**: Webpack 在开发模式下需要将所有模块打包成一个或多个 bundle，这个过程需要解析、编译和优化所有模块，即使只修改了一个文件，也需要重新打包整个应用。
   - **Vite**: Vite 利用了现代浏览器对 ES 模块的原生支持，直接在浏览器中加载 ES 模块文件。Vite 只在开发模式下提供一个轻量级的开发服务器，不需要打包整个应用，因此启动速度更快。

### 2. **按需编译**
   - **Webpack**: Webpack 在开发模式下需要预先编译所有模块，即使这些模块在当前页面中并不需要。
   - **Vite**: Vite 采用按需编译的策略，只有在浏览器请求某个模块时，Vite 才会对其进行编译。这种方式大大减少了启动时间和内存占用。

### 3. **热模块替换（HMR）**
   - **Webpack**: Webpack 的热模块替换（HMR）需要通过 WebSocket 与开发服务器通信，并且需要重新打包和更新整个模块树。
   - **Vite**: Vite 的 HMR 更加高效，因为它直接利用浏览器的原生 ES 模块加载机制，只更新修改的模块，而不需要重新打包整个应用。

### 4. **预构建依赖**
   - **Webpack**: Webpack 在开发模式下需要解析和编译所有依赖，包括第三方库。
   - **Vite**: Vite 在启动时会预构建项目中的依赖（使用 esbuild），这些依赖通常不会频繁变化，因此可以大大加快启动速度。

### 5. **轻量级开发服务器**
   - **Webpack**: Webpack 的开发服务器（webpack-dev-server）需要处理复杂的打包逻辑，包括模块解析、编译、优化等。
   - **Vite**: Vite 的开发服务器非常轻量级，主要负责提供静态文件服务和按需编译，因此启动速度更快。

### 6. **esbuild 加速**
   - **Webpack**: Webpack 使用 JavaScript 编写的编译器，速度相对较慢。
   - **Vite**: Vite 在预构建依赖时使用 esbuild，这是一个用 Go 语言编写的编译器，速度比 JavaScript 编写的编译器快得多。

### 7. **无打包模式**
   - **Webpack**: Webpack 在开发模式下仍然需要打包，即使使用 `webpack-dev-server`。
   - **Vite**: Vite 在开发模式下不需要打包，直接在浏览器中加载 ES 模块文件，因此启动速度更快。

### 8. **缓存机制**
   - **Webpack**: Webpack 在开发模式下没有充分利用缓存机制，每次启动都需要重新解析和编译所有模块。
   - **Vite**: Vite 利用缓存机制，只有在文件发生变化时才会重新编译，其他情况下直接使用缓存，因此启动速度更快。

### 总结
Vite 通过利用现代浏览器对 ES 模块的原生支持、按需编译、高效的 HMR、预构建依赖、轻量级开发服务器、esbuild 加速、无打包模式和缓存机制等策略，大大提高了开发模式的启动速度和热更新速度，使得开发体验更加流畅。